# Реализация различных алгоритмов

## 1. Сортировка
Сортировка пузырьком (Bubble Sort): Простой, но неэффективный алгоритм, который многократно проходит по списку, сравнивая и меняя соседние элементы.
Временная сложность: O(n^2) в худшем и среднем случае, O(n) в лучшем случае (если массив уже отсортирован).
Примечание: Это один из самых неэффективных алгоритмов сортировки для больших массивов.

Сортировка выбором (Selection Sort): Находит наименьший элемент и перемещает его в начало списка, повторяя процесс для оставшейся части.
Временная сложность: O(n^2) в худшем, среднем и лучшем случаях.
Примечание: Этот алгоритм также неэффективен для больших массивов и не использует дополнительную память.

Сортировка вставками (Insertion Sort): Постепенно строит отсортированный массив, вставляя элементы на свои места.
Временная сложность: O(n^2) в худшем и среднем случае, O(n) в лучшем случае (если массив уже отсортирован).
Примечание: Хорошо работает для небольших массивов и частично отсортированных данных.

Сортировка слиянием (Merge Sort): Разделяет массив на подмассивы, сортирует их и затем объединяет.
Временная сложность: O(n log n) в худшем, среднем и лучшем случаях.
Примечание: Это стабильный алгоритм сортировки, который требует дополнительной памяти для хранения временных массивов.

Быстрая сортировка (Quick Sort): Разделяет массив на две части по опорному элементу и рекурсивно сортирует каждую часть.
Временная сложность: O(n log n) в среднем и лучшем случаях, O(n^2) в худшем случае (например, если массив уже отсортирован и выбирается плохой опорный элемент).
Примечание: Это один из самых быстрых алгоритмов сортировки для больших массивов, но он не является стабильным.

Самые эффективные: Merge Sort и Quick Sort (в большинстве случаев).
Наименее эффективные: Bubble Sort, Selection Sort и Insertion Sort (в основном для больших массивов).


## 2. Поиск
Линейный поиск (Linear search): Проверяет каждый элемент массива по очереди, пока не найдет нужный.
Сложность:
Лучший случай: O(1) — элемент найден на первой позиции.
Средний и худший случай: O(n) — когда элемент находится в конце массива или отсутствует.
Примечание: Линейный поиск прост в реализации и может быть полезен для небольших массивов или когда данные не отсортированы. Однако для больших отсортированных массивов лучше использовать более эффективные алгоритмы, такие как бинарный поиск.

Бинарный поиск (Binary search): Работает на отсортированных массивах, деля массив пополам и сравнивая средний элемент с искомым значением.
Сложность:
Лучший случай: O(1) — элемент найден на первой проверке.
Средний и худший случай: O(log n) — количество элементов уменьшается вдвое на каждой итерации.
Примечание: Бинарный поиск эффективен для больших отсортированных массивов и является одним из самых быстрых способов поиска элемента в таком массиве.


## 3. Графы
Алгоритм Дейкстры: Находит кратчайший путь от одной вершины графа к всем остальным.
Временная сложность: O((V + E) log V), где V — количество вершин, E — количество ребер. Это связано с тем, что каждая вершина и каждое ребро обрабатываются, а операции с приоритетной очередью занимают логарифмическое время.
Пространственная сложность: O(V), так как мы храним расстояния и граф в памяти.

Алгоритм Флойда-Уоршелла: Находит кратчайшие пути между всеми парами вершин.
Временная сложность: O(V^3), где V — количество вершин. Это связано с тремя вложенными циклами, каждый из которых проходит по всем вершинам.
Пространственная сложность: O(V^2), так как мы храним матрицу расстояний в памяти.
